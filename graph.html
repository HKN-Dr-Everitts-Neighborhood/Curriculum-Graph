<html>
<head>

<script src="d3.v2.js" type="text/javascript"></script>

<style>
.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

.box {
  border: 1px solid black;
  width: 150px;
  margin: 2px;
  padding: 1px;
}
</style>

</head>
<body>

<svg xlmns="http://www.w3.org/2000/svg" version="1.1" id="chart"></svg>

<script type="text/javascript">
var json = [
  {
    "name": "flare",
    "prereqs": [[]]
  },
  {"name": "AgglomerativeCluster", "prereqs": [["flare"]]},
  {"name": "CommunityStructure", "prereqs": [["flare"]]},
  {"name": "HierarchicalCluster", "prereqs": [["flare", "CommunityStructure"]]},
  {"name": "MergeEdge", "prereqs": [["flare"]]}
 ];

function DAG(canvas) {

  this.nodes = {};
  this.roots = [];
  
  this.addNode = function(name) {
    var new_node = {name: name, children: [], parents: []};
    this.nodes[name] = new_node;
    return name;
  };
  
  this.addEdge = function(node1, node2) {
    this.nodes[node1].children.push(node2);
    this.nodes[node2].parents.push(node1);
  };

  this.find_roots = function()
  {
    this.roots = [];

    for (var node in this.nodes) {
      if (this.nodes[node].parents.length === 0)
        this.roots.push(node);
    }
  };

  this.postorder = function(start, reached) {
    var order = [];

    if (!(start.name in reached))
    {
      reached[start.name] = 1;

      for (var i = 0; i < start.children.length; i++)
      {
        order = order.concat(this.postorder(this.nodes[start.children[i]], reached));
      }
      order.push(start.name);
    }

    return order;
  };

  this.compute_order = function()
  {
    //parents isn't used by postorder, so we ignore it
    var fake_entry_node = {children: this.roots, name: "__fake_entry"};
    var reached = {};
    var order = this.postorder(fake_entry_node, reached);

    order.pop();
    order.reverse();
    return order;
  };

  this.layout = function()
  {
    //order the vertices
    this.find_roots();
    var ordering = this.compute_order(); // the topological order

    // Assign levels, and build a mapping of the levels
    var total_max = -1;
    var levels = [];

    for (var i = 0; i < ordering.length; i++)
    {
      var cur_node = this.nodes[ordering[i]];
      var max_level = -1; //one less than roots' level
      
      for (var j = 0; j < cur_node.parents.length; j++)
        if (this.nodes[cur_node.parents[j]].level > max_level)
          max_level = this.nodes[cur_node.parents[j]].level;

      cur_node.level = max_level+1;
      console.log("Assigned level of " + cur_node.level);
      if (cur_node.level > total_max)
      {
        total_max = cur_node.level;
	levels.push([]);

        // Sanity check, remove later
	if (levels.length-1 !== cur_node.level)
	  console.log("ERROR!");
	
	levels[levels.length-1].push(cur_node.name);
      }
      else
      	levels[cur_node.level].push(cur_node.name);
    }

    console.log(levels);
    // Assign positions
    for (var i=0; i < levels.length; i++)
    {
      console.log("Layout!");
      for (var j=0; j < levels[i].length; j++)
      {
        this.nodes[levels[i][j]].x = i*150;
	this.nodes[levels[i][j]].y = j*50+50;
      }
    }
  };

  this.draw = function() {
    this.layout();
    
    var node_list = [];
    for (var node in this.nodes)
    {
      node_list.push(node);
    }

    d3.select(canvas).selectAll("g").data(node_list)
      .enter().append("g").attr("transform", 
        function(datum){
	  console.log(datum, g.nodes[datum]);
	  return "translate(" + g.nodes[datum].x + "," + g.nodes[datum].y + ")";
	}
      )
      .append("text").text(function(datum){return datum;})

  };
}

var g = new DAG("#chart");

var makegraph = function(json) {
  var index = {};

  for (var i = 0; i < json.length; i++) {
    //json[i].children = [];
  
    index[json[i].name] = json[i];
    json[i].node = g.addNode(json[i].name);
  }
 

  //Currently, only support prereqs (no coreqs)

  for (var i = 0; i < json.length; i++)
  {
    for (var j=0; j < json[i].prereqs.length; j++)
    {
      var p = json[i].prereqs[j];
      for (var k = 0; k < p.length; k++)
      {
        //index[p[k]].children.push(json[i]);
        g.addEdge(index[p[k]].node, json[i].node);
      }
    }
  }
 
  g.draw();
};

makegraph(json);

</script>

</body>
</html>
